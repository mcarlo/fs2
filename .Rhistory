comparisonTied <- comparisonPicksScores >= apply(fanScoreSubset, 1, max)
outright <- which(colSums(comparisonFirst) == max(colSums(comparisonFirst)))
mostwins <- which(colSums(comparisonTied) == max(colSums(comparisonTied)))
# comparisonPicks[, outright]
# comparisonPicks[, mostwins]
colSums(comparisonFirst)[outright]
colSums(comparisonTied)[mostwins]
poolsize <- 32
sampleFans <- matrix(sample(1:2000, 2000 * poolsize, replace = T), nrow = 2000)
for (i in 1:2000){
fanScoreSubset[i, ] <- fanScores[i, sampleFans[i, ]]
}
comparisonFirst <- comparisonPicksScores > apply(fanScoreSubset, 1, max)
comparisonTied <- comparisonPicksScores >= apply(fanScoreSubset, 1, max)
outright <- which(colSums(comparisonFirst) == max(colSums(comparisonFirst)))
mostwins <- which(colSums(comparisonTied) == max(colSums(comparisonTied)))
fanScoreSubset <- matrix(rep(0, 2000 * poolsize), nrow = 2000)
sampleFans <- matrix(sample(1:2000, 2000 * poolsize, replace = T), nrow = 2000)
for (i in 1:2000){
fanScoreSubset[i, ] <- fanScores[i, sampleFans[i, ]]
}
comparisonFirst <- comparisonPicksScores > apply(fanScoreSubset, 1, max)
comparisonTied <- comparisonPicksScores >= apply(fanScoreSubset, 1, max)
outright <- which(colSums(comparisonFirst) == max(colSums(comparisonFirst)))
mostwins <- which(colSums(comparisonTied) == max(colSums(comparisonTied)))
# comparisonPicks[, outright]
# comparisonPicks[, mostwins]
colSums(comparisonFirst)[outright]
colSums(comparisonTied)[mostwins]
poolsize <- 7
fanScoreSubset <- matrix(rep(0, 2000 * poolsize), nrow = 2000)
sampleFans <- matrix(sample(1:2000, 2000 * poolsize, replace = T), nrow = 2000)
for (i in 1:2000){
fanScoreSubset[i, ] <- fanScores[i, sampleFans[i, ]]
}
comparisonFirst <- comparisonPicksScores > apply(fanScoreSubset, 1, max)
comparisonTied <- comparisonPicksScores >= apply(fanScoreSubset, 1, max)
outright <- which(colSums(comparisonFirst) == max(colSums(comparisonFirst)))
mostwins <- which(colSums(comparisonTied) == max(colSums(comparisonTied)))
# comparisonPicks[, outright]
# comparisonPicks[, mostwins]
colSums(comparisonFirst)[outright]
colSums(comparisonTied)[mostwins]
comparisonPicks[, outright]
comparisonPicks[, mostwins]
namedVec <- c(first = 127, second = 33, third = 5)
nnamedVec[-2]
namedVec[-2]
typeof(namedVec)
str(namedVec)
shiny::runApp('GitHub/rdt')
source('~/GitHub/fs2/app.R', echo=TRUE)
source('~/GitHub/fs2/app.R', echo=TRUE)
source('~/GitHub/fs2/app.R', echo=TRUE)
source('~/GitHub/fs2/app.R', echo=TRUE)
source('~/GitHub/fs2/app.R', echo=TRUE)
islands
source('~/GitHub/fs2/app.R', echo=TRUE)
source('~/GitHub/fs2/app.R', echo=TRUE)
source('~/GitHub/fs2/app.R', echo=TRUE)
source('~/GitHub/fs2/app.R', echo=TRUE)
source('~/GitHub/fs2/app.R', echo=TRUE)
head(islands)
AirPassengers
source('~/GitHub/fs2/app.R', echo=TRUE)
?switch
source('~/GitHub/fs2/app.R', echo=TRUE)
source('~/GitHub/fs2/app.R', echo=TRUE)
ncol(AirPassengers)
ncol(iris)
ncol(USArrests)
source('~/GitHub/fs2/app.R', echo=TRUE)
rm(list = ls())
iar <- read.csv("C:/userdata/iar2012.csv", stringsAsFactors=FALSE)
library(foreach)
currentYear <- 2015
qxCurrent <- function(qx, scaleG2, current = currentYear){
n <- current - 2012
scalingFactor <- (1 - scaleG2) ^ n
qxNow <- round(qx * scalingFactor, 6)
qxNow
}
genJavaDeathProb <- function(age, qx, gender) { #age = iar$age; qx = iar$qxFemale; gender = "female"
nRows <- length(qx)
deathProbs <- foreach(i = 1:nRows, .combine = c) %do% {
noquote(paste0("deathProbability_IAR_", gender, "[", age[i], "] = ", qx[i], ";"))
}
deathProbs
}
genJavaLifeExp <- function(age, ex, gender) { #age = iar$age; qx = iar$qxFemale; gender = "female"
nRows <- length(ex)
lifeExps <- foreach(i = 1:nRows, .combine = c) %do% {
noquote(paste0("lifeExpectancy_IAR_", gender, "[", age[i], "] = ", ex[i], ";"))
}
lifeExps
}
qx2015female <- qxCurrent(iar$qxFemale, iar$scaleG2Female, 2015)
qx2015male <- qxCurrent(iar$qxMale, iar$scaleG2Male, 2015)
deathProbFemale <- sapply(genJavaDeathProb(iar$age, qx2015female, "female"), noquote)
deathProbMale <- sapply(genJavaDeathProb(iar$age, qx2015male, "male"), noquote)
survivalMale <- c(1, cumprod((1-qx2015male[-(120:121)])))
survivalFemale <- c(1, cumprod((1-qx2015female[-(120:121)])))
lxMale <- 1000000 * survivalMale
TxMale <- cumsum(lxMale[order(-age[1:120])])[order(-age[1:120])]
exMale <- round(TxMale/lxMale, 2)
age <- iar$age
qx2015female <- qxCurrent(iar$qxFemale, iar$scaleG2Female, 2015)
qx2015male <- qxCurrent(iar$qxMale, iar$scaleG2Male, 2015)
deathProbFemale <- sapply(genJavaDeathProb(iar$age, qx2015female, "female"), noquote)
deathProbMale <- sapply(genJavaDeathProb(iar$age, qx2015male, "male"), noquote)
survivalMale <- c(1, cumprod((1-qx2015male[-(120:121)])))
survivalFemale <- c(1, cumprod((1-qx2015female[-(120:121)])))
lxMale <- 1000000 * survivalMale
TxMale <- cumsum(lxMale[order(-age[1:120])])[order(-age[1:120])]
exMale <- round(TxMale/lxMale, 2)
exMale[68]
survivalMale
payments <- rep(0, 121)
payments[68:121] <- 36000
payments
discount <- (1.0228) ^ -age
discount
discount <- (1.0228) ^ -(age - 67)
discount[1:67] <- 0
discount
discount * payments
sum(discount * payments * survivalMale)/survivalMale[68]
sum(discount[1:120] * payments[1:120] * survivalMale)/survivalMale[68]
sum(discount[1:120] * payments[1:120] * survivalMale)
qx2015male <- qxCurrent(iar$qxMale, iar$scaleG2Male, 2015)
survivalMale <- c(1, cumprod((1-qx2015male[-(121)])))
survivalFemale <- c(1, cumprod((1-qx2015female[-(121)])))
lxMale <- 1000000 * survivalMale
TxMale <- cumsum(lxMale[order(-age[1:120])])[order(-age[1:120])]
exMale <- round(TxMale/lxMale, 2) #exMale[68]
lxFemale <- 1000000 * survivalFemale
TxFemale <- cumsum(lxFemale[order(-age[1:120])])[order(-age[1:120])]
exFemale <- round(TxFemale/lxFemale, 2)
lifeExpMale <- sapply(genJavaLifeExp(iar$age[-121], exMale, "male"), noquote)
lifeExpFemale <- sapply(genJavaLifeExp(iar$age[-121], exFemale, "female"), noquote)
javaMatrix <- t(matrix(cbind(lifeExpMale, lifeExpFemale, deathProbMale[-121], deathProbFemale[-121]), ncol = 4))
javaCode <- as.vector(javaMatrix)
javaMatrix <- t(matrix(cbind(lifeExpMale, lifeExpFemale, deathProbMale, deathProbFemale), ncol = 4))
javaCode <- as.vector(javaMatrix)
survivalMale
payments <- rep(0, 121)
payments[68:121] <- 36000
payments
discount <- (1.0228) ^ -(age - 67)
discount[1:67] <- 0
discount
sum(discount * payments * survivalMale)/survivalMale[68]
exMale[19]
exMale[61]
rp <- read.csv("C:/userdata/rp2014.csv", stringsAsFactors=FALSE)
rp
ageRP <- rp$Age
qxMaleRP <- rp$HA_male; qxFemaleRP <- rp$HA_female
qxMaleRP
qxMaleRP[is.na(qxMaleRP)] <- 0; qxFemaleRP[is.na(qxFemaleRP)] <- 0;
qxMaleRP
qxFemaleRP
survivalM_RP <- cumprod((1-qxMaleRP))
survivalF_RP <- cumprod((1-qxFemaleRP))
survivalF_RP
lxM_RP <- 1000000 * survivalM_RP
TxM_RP <- cumsum(lxM_RP[order(-age)])[order(-age)]
TxM_RP <- cumsum(lxM_RP[order(-ageRP)])[order(-ageRP)]
exM_RP <- round(TxM_RP/lxM_RP, 2) #exMale[68]
exM_RP[ageRP == 60]
exM_RP[60]
exM_RP
ageRP
ageRP == 60
which(ageRP == 60)
exM_RP[which(ageRP == 60)]
exM_RP[which(ageRP == 70)]
lxF_RP <- 1000000 * survivalF_RP
TxF_RP <- cumsum(lxF_RP[order(-ageRP)])[order(-ageRP)]
exF_RP <- round(TxF_RP/lxF_RP, 2)
exF_RP[which(ageRP == 60)]
exF_RP[which(ageRP == 70)]
load("deploy.RData") #load("tvt.RData") #save.image("tvt.RData")
setwd("~/GitHub/sk")
load("deploy.RData") #load("tvt.RData") #save.image("tvt.RData")
library(stringi); library(compiler)
suppressMessages(suppressWarnings(library(data.table)))
cmpPred
getConf
getPred
genLegend
cmpPredNT
cmpPred
subTrain
subTrainNT
shiny::runApp('~/GitHub/fs2')
shiny::runApp('~/GitHub/fs2')
shiny::runApp('~/GitHub/fs2')
shiny::runApp('~/GitHub/fs2')
shiny::runApp('~/GitHub/fs2')
shiny::runApp('~/GitHub/fs2')
shiny::runApp('~/GitHub/rdt')
shiny::runApp('~/GitHub/shiny-examples/013-selectize')
shiny::runApp('~/GitHub/shiny-examples/017-select-vs-selectize')
shiny::runApp('~/GitHub/fs2')
shiny::runApp('~/GitHub/fs2')
setwd("~/GitHub/fs2")
load("fansimsSkeleton.RData")
source("data_to_load.R") #getwd()
processFile("2014week17.csv")
genMtx()
simParams()
save.image("useWeeklyFile.RData")
rm(list = ls())
library(shiny)
load("useWeeklyFile.RData")
input <- data.frame(players = 250, first = 225, second = 125, third = 50)
simulatePool(numFans = input$players, payouts = c(input$first, input$second, input$third))
topWin
topMoney
strategies[, topWin]
strategies[, topMoney]
favorites
gameRanks <- games:1
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
load("useWeeklyFile.RData")
gameRanks <- games:1
#input <- data.frame(players = 250, first = 225, second = 125, third = 50)
simulatePool(numFans = input$players, payouts = c(input$first, input$second, input$third))
input <- data.frame(players = 250, first = 225, second = 125, third = 50)
reactive({simulatePool(numFans = input$players, payouts = c(input$first, input$second, input$third))})
simulatePool(numFans = input$players, payouts = c(input$first, input$second, input$third))
rm(list = ls())
load("useWeeklyFile.RData")
gameRanks <- games:1
resultsMatrix <- littleSim(numFans = input$players)
rm(list = ls())
load("fansimsSkeleton.RData")
source("data_to_load.R") #getwd()
processFile("2014week16.csv")
genMtx()
simParams()
rankMatrix <- littleSim(numFans = 250, totalPointsMatrix = totalPointsIter,
upsetPointsMatrix = upsetPoints)
save.image("useWeeklyFile.RData")
rm(list = ls())
load("useWeeklyFile.RData")
rm(list = ls())
load("fansimsSkeleton.RData")
source("data_to_load.R") #getwd()
processFile("2014week16.csv")
genMtx()
simParams()
rankMatrix <- littleSim(numFans = 250, totalPointsMatrix = totalPointsIter,
upsetPointsMatrix = upsetPoints)
rm(list = ls())
load("fansimsSkeleton.RData")
source("data_to_load.R") #getwd()
processFile("2014week16.csv")
genMtx()
simParams()
littleSim
rm(list = ls())
load("fansimsSkeleton.RData")
source("data_to_load.R") #getwd()
processFile("2014week16.csv")
genMtx()
simParams()
rankMatrix <- littleSim(numFans = 250, totalPointsMatrix = totalPointsIter,
upsetPointsMatrix = upsetPoints)
numFans = 250, totalPointsMatrix = totalPointsIter
numFans = 250
totalPointsMatrix = totalPointsIter
upsetPointsMatrix = upsetPoints
totalPointsMatrix = totalPointsMatrix[, 1:numFans]
myRanks <- rank(winProb, ties.method = "random")+premiumPts
myPoints <- as.vector(crossprod(myRanks, simOutcomes2[, 1:numFans])) # * myRanks
upsetPoints <<- t(crossprod(upsetMatrix[selectRowsPrem,selectRowsPrem,  drop = F], simOutcomes2[, 1:numFans]) +
crossprod(upsetDiagMatrix[selectRowsPrem,selectRowsPrem,  drop = F], (1 - simOutcomes2[, 1:numFans])))
upsetMatrix[selectRowsPrem,selectRowsPrem,  drop = F]
myPoints <- as.vector(crossprod(myRanks, simOutcomes2[, 1:numFans])) # * myRanks
stratMatrix <- matrix(cbind(myPoints[resultIndex], upsetPointsMatrix[resultIndex,]), nrow = 2000)
stratMatrix <- matrix(cbind(myPoints[resultIndex], upsetPoints[resultIndex,]), nrow = 2000)
upsetPoints
resultIndex
rm(list = ls())
load("fansimsSkeleton.RData")
source("data_to_load.R") #getwd()
processFile("2014week16.csv")
genMtx()
simParams()
numFans = 250
totalPointsMatrix = totalPointsIter
upsetPointsMatrix = upsetPoints
totalPointsMatrix = totalPointsMatrix[, 1:numFans]
upsetPoints <<- t(crossprod(upsetMatrix[selectRowsPrem,selectRowsPrem,  drop = F], simOutcomes2[, 1:numFans]) +
crossprod(upsetDiagMatrix[selectRowsPrem,selectRowsPrem,  drop = F], (1 - simOutcomes2[, 1:numFans])))
myRanks <- rank(winProb, ties.method = "random")+premiumPts
myPoints <- as.vector(crossprod(myRanks, simOutcomes2[, 1:numFans])) # * myRanks
myPoints <- as.vector(crossprod(myRanks, simOutcomes2)) # * myRanks
stratMatrix <- matrix(cbind(myPoints[resultIndex], upsetPoints[resultIndex,]), nrow = 2000)
upsetPoints <<- t(crossprod(upsetMatrix[selectRowsPrem,selectRowsPrem,  drop = F], simOutcomes2) +
crossprod(upsetDiagMatrix[selectRowsPrem,selectRowsPrem,  drop = F], (1 - simOutcomes2)))
myRanks <- rank(winProb, ties.method = "random")+premiumPts
myPoints <- as.vector(crossprod(myRanks, simOutcomes2)) # * myRanks
stratMatrix <- matrix(cbind(myPoints[resultIndex], upsetPoints[resultIndex,]), nrow = 2000)
rankMatrix <- apply(stratMatrix, 2, rankVinM_Q, pointsMtrx = totalPointsMatrix)
processFile <- function(weekFilename = "2014week11.csv"){
#rm(list = ls())
#load("fansimsSkeleton.RData")
#weekFilename = "2014week17.csv"
# these objects will vary by week
#
#setwd("D:/Documents/GitHub/fs2")
weekFile <- read.csv(weekFilename, stringsAsFactors = F, colClasses = c("character", "numeric", "integer",
"numeric", "numeric", "numeric", "numeric",
"character"))
weekFile <<- weekFile[order(-weekFile$Confidence),]
winProb <<- weekFile[, 2]
if (max(winProb) > 1) {winProb <<- winProb/100.0}
games <<- length(winProb)
gameRanks <<- games:1
favorites <<- weekFile$Victor
strategies <<- matrix(rep(favorites, 14), ncol = 14)
# simulate whether fans pick the favorite
fanProb <<- weekFile$FanProb
# simulate favorite confidence and underdog confidence
favConf <<- weekFile$FavConf
dogConf <<- weekFile$DogConf
oppLabel <- function(c){paste0(c, "'s opponent")}
dogs <<- sapply(favorites, oppLabel)
if(dim(weekFile)[2] == 8) {dogs <<- weekFile$Underdog}
#save.image("procFile.RData")
### dependent matrices
}
genMtx <- function(){
#rm(list = ls())
#load("procFile.RData")
#games <<- length(winProb)
premium <<- 16 - games
prem <<- FALSE
premiumPts <<- 0 + prem * premium
selectRows <<- (1:games)
selectRowsPrem <<- selectRows + (1 - prem) * premium
for (j in 2:14){ # j = 2
strategies[j - 1, j] <- dogs[j-1] #weekFile[1:3, ]; favorites[j]
strategies[, j] <- strategies[order(-(upsetMatrix[selectRowsPrem, selectRowsPrem] + upsetDiagMatrix[selectRowsPrem, selectRowsPrem])[ , j - 1]), j]
}
strategies <<- strategies
simPicks <- matrix((simplayerCols[selectRows]  < fanProb)*1, nrow = games, ncol = playerCols)
simFavs <- matrix(qbinom(simRand[1:games], games, (favConf - .5)/games, lower.tail = T), nrow = games, ncol = playerCols) + (runif(playerCols * games) - .5)
# simFavs[1:10, 1:10]
simDogs <- matrix(qbinom(simRand[1:games], games, (dogConf - .5)/games, lower.tail = T), nrow = games, ncol = playerCols) + (runif(playerCols * games) - .5)
simPrior <- matrix(qbinom(simRand[1:games], games, 0.5, lower.tail = T), nrow = games, ncol = playerCols) + (runif(playerCols * games) - .5)
#rm(simplayerCols); rm(simRand)
simRaw <- (simPrior + simFavs *simPicks + simDogs *(1 - simPicks))/2
simRanks <- apply(simRaw[selectRows,], 2, rank) + premiumPts # max(apply(simRanks, 2, max))
#rm(simRaw); rm(simPrior); rm(simFavs); rm(simDogs)
simOutcomes2 <<- (simOutcomes2[selectRows,] <= winProb) * 1
totalPoints <<- t(crossprod((simPicks * simRanks), simOutcomes2) +
crossprod((1 - simPicks) * simRanks, (1 - simOutcomes2)))
upsetPoints <<- t(crossprod(upsetMatrix[selectRowsPrem,selectRowsPrem,  drop = F], simOutcomes2) +
crossprod(upsetDiagMatrix[selectRowsPrem,selectRowsPrem,  drop = F], (1 - simOutcomes2)))
}
# cmpMtx <- cmpfun(genMtx)
simParams <- function(){
suppressMessages(require(foreach))
maxIter <<- 2000
set.seed(123)
# resultIndex <<- sample(1:2000, maxiter, replace = TRUE)
fanIndex <<- matrix(as.numeric(foreach(resultIndex, .combine = rbind) %do% as.numeric(sample(1:playerCols, 250, replace = T))), nrow = 2000)
rowMax <- 2000
stratWins <<- rep(0, 14)
stratPlace <<- rep(0, 14)
stratShow <<- rep(0, 14)
totalPointsIter <<- matrix(foreach(i = 1:rowMax, .combine = rbind) %do%
# i = 1
totalPoints[resultIndex[i], fanIndex[i,]], nrow = rowMax, ncol = 250)
}
rankVinM_Q <- function(vec = myPointsVector[resultIndex], pointsMtrx = totalPointsIter){
temp <- -matrix(cbind(vec, pointsMtrx), ncol = dim(pointsMtrx)[2] + 1)
rankM <- t(apply(temp, 1, rank, ties.method = "min"))[, 1]
}
littleSim <- function(numFans = 250, totalPointsMatrix = totalPointsIter,
upsetPointsMatrix = upsetPoints){# myPointsVector = myPoints){
totalPointsMatrix = totalPointsMatrix[, 1:numFans]
upsetPoints <<- t(crossprod(upsetMatrix[selectRowsPrem,selectRowsPrem,  drop = F], simOutcomes2) +
crossprod(upsetDiagMatrix[selectRowsPrem,selectRowsPrem,  drop = F], (1 - simOutcomes2)))
myRanks <- rank(winProb, ties.method = "random")+premiumPts
myPoints <- as.vector(crossprod(myRanks, simOutcomes2)) # * myRanks
stratMatrix <- matrix(cbind(myPoints[resultIndex], upsetPoints[resultIndex,]), nrow = 2000)
rankMatrix <- apply(stratMatrix, 2, rankVinM_Q, pointsMtrx = totalPointsMatrix)
stratWins <<- colSums(rankMatrix[, 1:14] == 1)
stratPlace <<- colSums(rankMatrix[, 1:14] == 2)
stratShow <<- colSums(rankMatrix[, 1:14] == 3)
resultsMatrix <- as.matrix(cbind(stratWins, stratPlace, stratShow), nrow = 6, ncol = 3) * 17.0 / maxIter
resultsMatrix
}
computeWinnings <- function(resultsMatrix, payouts = c(100, 0, 0)) {
winnings <- round(as.data.frame(t((resultsMatrix %*% payouts))), 1)
colnames(winnings) <- c("WTP", "Fav", "Fav-1", "Fav-2", "Fav-3", "Fav-4",
"Fav-5", "Fav-6", "Fav-7", "Fav-8", "Fav-9",
"Fav-10", "Fav-11", "Fav-12")
rownames(resultsMatrix) <- colnames(winnings)
winnings
}
countITM <- function(resultsMatrix, payouts = c(100, 0, 0)) {
inTheMoney <- round(rowSums(resultsMatrix %*% (1*(payouts > 0))), 2)
inTheMoney
}
simulatePool <- function(numFans = 100,
payouts = c(100, 0, 0), totalPointsMatrix = totalPointsIter[, 1:numFans],
myPointsVector = myPoints, upsetPointsMatrix = upsetPoints){
myRanks <<- rank(winProb, ties.method = "random")+premiumPts
myPoints <<- as.vector(crossprod(myRanks, simOutcomes2)) # * myRanks
stratMatrix <- matrix(cbind(myPoints[resultIndex], upsetPointsMatrix[resultIndex,]), nrow = 2000)
rankMatrix <- apply(stratMatrix, 2, rankVinM_Q, pointsMtrx = totalPointsMatrix)
stratWins <- colSums(rankMatrix[, 1:14] == 1)
stratPlace <- colSums(rankMatrix[, 1:14] == 2)
stratShow <- colSums(rankMatrix[, 1:14] == 3)
resultsMatrix <<- as.matrix(cbind(stratWins, stratPlace, stratShow), nrow = 6, ncol = 3) * 17.0 / maxIter
winnings <<- round(as.data.frame(t((resultsMatrix %*% payouts))), 1)
inTheMoney <<- round(rowSums(resultsMatrix %*% (1*(payouts > 0))), 2)
colnames(winnings) <<- c("WTP", "Fav", "Fav-1", "Fav-2", "Fav-3", "Fav-4",
"Fav-5", "Fav-6", "Fav-7", "Fav-8", "Fav-9",
"Fav-10", "Fav-11", "Fav-12")
rownames(resultsMatrix) <<- colnames(winnings)
#   top3Money()
#   top3Dollars()
topWin <<- order(-winnings[1,])[1:3]
topMoney <<- order(-inTheMoney)[1:3]
#print(resultsMatrix)
#   print(rbind(round(winnings, 2), round(apply(resultsMatrix, 1, sum), 1)))
}
rm(list = ls())
load("fansimsSkeleton.RData")
source("data_to_load.R") #getwd()
processFile("2014week16.csv")
genMtx()
simParams()
rankMatrix <- littleSim(numFans = 250, totalPointsMatrix = totalPointsIter,
upsetPointsMatrix = upsetPoints)
save.image("useWeeklyFile.RData")
rm(list = ls())
rm(list = ls())
load("useWeeklyFile.RData")
results <- resultsMatrix[, 1:input$players]
results <- littleSim(numFans = input$players)
input <- data.frame(players = 250, first = 225, second = 125, third = 50)
results <- littleSim(numFans = input$players)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
reactive({results <- littleSim(numFans = input$players)})
results <- littleSim(numFans = input$players)
winnings <- round(as.data.frame(t((results %*% input$payouts))), 1)
input$payouts
input <- data.frame(players = 250, first = 225, second = 125, third = 50)
winnings <- round(as.data.frame(t((results %*% c(input$first, input$second, input$third))), 1)
winnings <- round(as.data.frame(t((results %*% c(input$first, input$second, input$third)))), 1)
inTheMoney <- round(rowSums(results %*% (1*(c(input$first, input$second, input$third) > 0))), 2)
colnames(winnings) <- c("WTP", "Fav", "Fav-1", "Fav-2", "Fav-3", "Fav-4",
"Fav-5", "Fav-6", "Fav-7", "Fav-8", "Fav-9",
"Fav-10", "Fav-11", "Fav-12")
rownames(resultsMatrix) <- colnames(winnings)
rownames(results) <- colnames(winnings)
topWin <- order(-winnings[1,])[1:3]
topMoney <- order(-inTheMoney)[1:3]
shiny::runApp()
shiny::runApp()
shiny::runApp()
payouts
results
results <- littleSim(numFans = 10)
results
numFans
numFans = 10
results <- littleSim(numFans = numFans)
results
results <- littleSim(numFans = 10)
results
totalPointsMatrix <- totalPointsMatrix[, 1:numFans]
suppressMessages(require(foreach))
maxIter <<- 2000
set.seed(123)
fanIndex <<- matrix(as.numeric(foreach(resultIndex, .combine = rbind) %do% as.numeric(sample(1:playerCols, 250, replace = T))), nrow = 2000)
rowMax <- 2000
stratWins <<- rep(0, 14)
stratPlace <<- rep(0, 14)
stratShow <<- rep(0, 14)
totalPointsIter <<- matrix(foreach(i = 1:rowMax, .combine = rbind) %do%
totalPoints[resultIndex[i], fanIndex[i,]], nrow = rowMax, ncol = 250)
numFans
totalPointsMatrix <- totalPointsMatrix[, 1:numFans]
totalPointsMatrix = totalPointsIter
totalPointsMatrix <- totalPointsMatrix[, 1:numFans]
upsetPointsMatrix = upsetPoints
upsetPoints <<- t(crossprod(upsetMatrix[selectRowsPrem,selectRowsPrem,  drop = F], simOutcomes2) +
crossprod(upsetDiagMatrix[selectRowsPrem,selectRowsPrem,  drop = F], (1 - simOutcomes2)))
myRanks <- rank(winProb, ties.method = "random")+premiumPts
myPoints <- as.vector(crossprod(myRanks, simOutcomes2)) # * myRanks
stratMatrix <- matrix(cbind(myPoints[resultIndex], upsetPoints[resultIndex,]), nrow = 2000)
rankMatrix <- apply(stratMatrix, 2, rankVinM_Q, pointsMtrx = totalPointsMatrix)
stratWins <<- colSums(rankMatrix[, 1:14] == 1)
stratPlace <<- colSums(rankMatrix[, 1:14] == 2)
stratShow <<- colSums(rankMatrix[, 1:14] == 3)
resultsMatrix <- as.matrix(cbind(stratWins, stratPlace, stratShow), nrow = 6, ncol = 3) * 17.0 / maxIter
resultsMatrix
