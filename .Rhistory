it <- iforever(42)
nextElem(it)
nextElem(it)
unlist(as.list(it, n=6))
irep <- function(x, times) {
nextEl <- function() {
if (times > 0)
times <<- times - 1
else
stop('StopIteration')
x
}
obj <- list(nextElem=nextEl)
class(obj) <- c('irep', 'abstractiter', 'iter')
obj
}
it <- irep(7, 6)
unlist(as.list(it))
ivector <- function(x, ...) {
i <- 1
it <- idiv(length(x), ...)
nextEl <- function() {
n <- nextElem(it)
ix <- seq(i, length=n)
i <<- i + n
x[ix]
}
obj <- list(nextElem=nextEl)
class(obj) <- c('ivector', 'abstractiter', 'iter')
obj
}
it <- ivector(1:25, chunks=3)
as.list(it)
hasNext <- function(obj, ...) {
UseMethod('hasNext')
}
hasNext.ihasNext <- function(obj, ...) {
obj$hasNext()
}
ihasNext <- function(it) {
if (!is.null(it$hasNext)) return(it)
cache <- NULL
has_next <- NA
nextEl <- function() {
if (!hasNx())
stop('StopIteration', call.=FALSE)
has_next <<- NA
cache
}
hasNx <- function() {
if (!is.na(has_next)) return(has_next)
tryCatch({
cache <<- nextElem(it)
has_next <<- TRUE
},
error=function(e) {
if (identical(conditionMessage(e), 'StopIteration')) {
has_next <<- FALSE
stop(e)
}
} else {
})
has_next
}
obj <- list(nextElem=nextEl, hasNext=hasNx)
class(obj) <- c('ihasNext', 'abstractiter', 'iter')
obj
}
it <- ihasNext(icount(3))
### R code from vignette source 'writing.Rnw'
###################################################
### code chunk number 1: loadLibs
###################################################
library(iterators)
###################################################
### code chunk number 2: iterable1
###################################################
it <- iter(list(1:2, 3:4))
###################################################
### code chunk number 3: iterable2
###################################################
nextElem(it)
nextElem(it)
tryCatch(nextElem(it), error=function(e) e)
###################################################
### code chunk number 4: nextElem.abstractiter
###################################################
iterators:::iter.iter
iterators:::nextElem.abstractiter
###################################################
### code chunk number 5: iter1
###################################################
iforever <- function(x) {
nextEl <- function() x
obj <- list(nextElem=nextEl)
class(obj) <- c('iforever', 'abstractiter', 'iter')
obj
}
###################################################
### code chunk number 6: runiter1
###################################################
it <- iforever(42)
nextElem(it)
nextElem(it)
###################################################
### code chunk number 7: runiter1.part2
###################################################
unlist(as.list(it, n=6))
###################################################
### code chunk number 8: iter2
###################################################
irep <- function(x, times) {
nextEl <- function() {
if (times > 0)
times <<- times - 1
else
stop('StopIteration')
x
}
obj <- list(nextElem=nextEl)
class(obj) <- c('irep', 'abstractiter', 'iter')
obj
}
###################################################
### code chunk number 9: runiter2
###################################################
it <- irep(7, 6)
unlist(as.list(it))
###################################################
### code chunk number 10: iter3
###################################################
ivector <- function(x, ...) {
i <- 1
it <- idiv(length(x), ...)
nextEl <- function() {
n <- nextElem(it)
ix <- seq(i, length=n)
i <<- i + n
x[ix]
}
obj <- list(nextElem=nextEl)
class(obj) <- c('ivector', 'abstractiter', 'iter')
obj
}
###################################################
### code chunk number 11: runiter3
###################################################
it <- ivector(1:25, chunks=3)
as.list(it)
###################################################
### code chunk number 12: generichasnext
###################################################
hasNext <- function(obj, ...) {
UseMethod('hasNext')
}
###################################################
### code chunk number 13: hasnextmethod
###################################################
hasNext.ihasNext <- function(obj, ...) {
obj$hasNext()
}
ihasNext <- function(it) {
if (!is.null(it$hasNext)) return(it)
cache <- NULL
has_next <- NA
nextEl <- function() {
if (!hasNx())
stop('StopIteration', call.=FALSE)
has_next <<- NA
cache
}
hasNx <- function() {
if (!is.na(has_next)) return(has_next)
tryCatch({
cache <<- nextElem(it)
has_next <<- TRUE
},
error=function(e) {
if (identical(conditionMessage(e), 'StopIteration')) {
has_next <<- FALSE
} else {
stop(e)
}
})
has_next
}
obj <- list(nextElem=nextEl, hasNext=hasNx)
class(obj) <- c('ihasNext', 'abstractiter', 'iter')
obj
}
it <- ihasNext(icount(3))
while (hasNext(it)) {
print(nextElem(it))
}
irecycle <- function(it) {
values <- as.list(iter(it))
i <- length(values)
nextEl <- function() {
i <<- i + 1
if (i > length(values)) i <<- 1
values[[i]]
}
obj <- list(nextElem=nextEl)
class(obj) <- c('irecycle', 'abstractiter', 'iter')
obj
}
it <- irecycle(icount(3))
unlist(as.list(it, n=9))
ilimit <- function(it, times) {
it <- iter(it)
nextEl <- function() {
if (times > 0)
times <<- times - 1
else
stop('StopIteration')
nextElem(it)
}
obj <- list(nextElem=nextEl)
class(obj) <- c('ilimit', 'abstractiter', 'iter')
obj
}
irep2 <- function(x, times)
ilimit(iforever(x), times)
it <- ihasNext(irep2('foo', 3))
while (hasNext(it)) {
print(nextElem(it))
}
iterable <- 1:3
n <- 3
it <- ilimit(irecycle(iterable), n * length(iterable))
unlist(as.list(it))
rep(iterable, n)
library("doParallel", lib.loc="~/R/win-library/3.1")
vignette("gettingstartedParallel")
x <- iris[which(iris[,5] != "setosa"), c(1,5)]
trials <- 10000
ptime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %dopar% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
ptime
stime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %do% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
stime
library(doParallel}
library(doParallel)
registerDoParallel(cores=3)
foreach(i=1:3) %dopar% sqrt(i)
ptime
x <- iris[which(iris[,5] != "setosa"), c(1,5)]
trials <- 10000
ptime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %dopar% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
ptime
stime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %do% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
stime
getDoParWorkers()
mcoptions <- list(preschedule=FALSE, set.seed=FALSE)
foreach(i=1:3, .options.multicore=mcoptions) %dopar% sqrt(i)
options(cores=2)
getDoParWorkers()
options(cores=3)
getDoParWorkers()
registerDoParallel(4)
options(cores=2)
getDoParWorkers()
stopCluster(cl)
install.packages(c("ape", "arules", "arulesViz", "BH", "bit64", "caret", "chron", "CORElearn", "DEoptimR", "devtools", "diptest", "dplyr", "DSL", "e1071", "ElemStatLearn", "evaluate", "excel.link", "forecast", "foreign", "formatR", "Formula", "gdata", "ggthemes", "glmnet", "gplots", "gridExtra", "gtools", "highlight", "highr", "Hmisc", "htmlTable", "htmlwidgets", "httr", "igraph", "installr", "jsonlite", "knitcitations", "knitr", "lattice", "lava", "lme4", "lmtest", "manipulate", "mapproj", "maps", "markdown", "mclust", "mime", "mnormt", "NLP", "NLPutils", "numDeriv", "openNLP", "openNLPdata", "pander", "party", "pgmm", "plotrix", "plyr", "polspline", "prettyR", "proxy", "pryr", "psych", "qdap", "qdapDictionaries", "qdapRegex", "Quandl", "R.utils", "R6", "rattle", "Rcpp", "RcppArmadillo", "RCurl", "RefManageR", "rgl", "rmarkdown", "rms", "robustbase", "ROCR", "RODBC", "roxygen2", "rpart", "RSNNS", "rstudioapi", "sandwich", "scales", "seriation", "shiny", "shinydashboard", "sjPlot", "sp", "stringdist", "stringi", "stringr", "strucchange", "testthat", "tis", "tm", "topicmodels", "tree", "treemap", "TSP", "TTR", "vcd", "XML"))
library(foreach)
foreach(i=1:10) %do% sample(c("H", "T"), 10000, replace=TRUE)
foreach(i=1:10) %dopar% sample(c("H", "T"), 10000, replace=TRUE)
library(doParallel)
cl <- makeCluster(2)
registerDoParallel(cores = 3)
options(cores)
options()
stopImplicitCluster()
sampleVec <- sample(1:16, size = 16)
sampleOutcomes <- sample(0:1, size = 160, replace = T)
crossprod(sampleVec, sampleOutcomes)
sampleOutcomes <- matrix(sample(0:1, size = 160, replace = T), nrow = 16)
crossprod(sampleVec, sampleOutcomes)
crossprod(rep(NULL, 16), sampleOutcomes)
crossprod(rep(0, 16), sampleOutcomes)
sampleMult <- sample(1:16, size = 64, replace = T)
calcPoints <- function(rankVec){
pointVec <- as.vector(t(crossprod(rankVec, simOutcomes2)))
}
calcPoints <- function(rankVec, outcomeMatrix = simOutcomes2){
pointVec <- as.vector(t(crossprod(rankVec, outcomeMatrix)))
}
calcPoints(sampleVec, sampleOutcomes)
calcPoints(sampleVec, outcomeMatrix = sampleOutcomes)
x <-calcPoints(sampleVec, outcomeMatrix = sampleOutcomes)
x
x <-calcPoints(sampleMult, outcomeMatrix = sampleOutcomes)
sampleMult <- matrix(sample(1:16, size = 64, replace = T), nrow = 16)
x <-calcPoints(sampleMult, outcomeMatrix = sampleOutcomes)
x
is.matrix(sampleMult)
is.matrix(sampleVec)
calcPoints <- function(rankVec, outcomeMatrix = simOutcomes2){
if (is.matrix(sampleVec)) {
pointVec <- as.matrix(t(crossprod(rankVec, outcomeMatrix)), nrow = dim(rankVec)[1])
}
pointVec <- as.vector(t(crossprod(rankVec, outcomeMatrix)))
}
x <-calcPoints(sampleMult, outcomeMatrix = sampleOutcomes)
x
calcPoints <- function(rankVec, outcomeMatrix = simOutcomes2){
if (is.matrix(sampleVec)) {
pointVec <- matrix(t(crossprod(rankVec, outcomeMatrix)), nrow = dim(rankVec)[1])
} else {
pointVec <- as.vector(t(crossprod(rankVec, outcomeMatrix)))
}
pointVec
}
x <-calcPoints(sampleMult, outcomeMatrix = sampleOutcomes)
x
x <-calcPoints(sampleVec, outcomeMatrix = sampleOutcomes)
x
x <-calcPoints(sampleMult, outcomeMatrix = sampleOutcomes)
x
sampleMult
apply(sampleMult, 2, calcPoints, outcomeMatrix = sampleOutcomes)
calcPoints <- function(rankVec, outcomeMatrix = simOutcomes2){
pointVec <- as.vector(t(crossprod(rankVec, outcomeMatrix)))
}
shiny::runApp('GitHub/fs2')
rm(list = ls())
genGameRanks <- function(nGames = 16) {nGames:1}
genSq <- function(nGames = 16){
matrix(rep(genGameRanks(nGames), times = nGames), ncol = nGames)
}
#genSq(14)
genZeroSq <- function(nGames = 16){
matrix(rep(0, nGames^2), ncol = nGames)
}
genZeroSq(15)
nGames = 16
altFavs <- genZeroSq(nGames)
altUpsets <- altFavs
altUpsetsRow <- altUpsets
startRanks <- genSq(nGames)
topCol = 5
altUpsets <- startRanks
for (j in 1:nGames){ #j = 1
threshold <- (nGames + 1 - j)
if (j < topCol){
altUpsets[j:(topCol - 1) ,j] <- startRanks[(j + 1):topCol ,j]
}
if (j > topCol){
altUpsets[(topCol + 1):j ,j] <- startRanks[topCol:(j-1) ,j]
}
}
altUpsets[topCol, ] <- genGameRanks(16)
altUpsets
altUpsets2 <- altUpsets
altUpsets2[topCol, ] <- 0
altUpsets2
altUpsetsRow
altUpsetsRow[topCol, ] <- genGameRanks()
altUpsetsRow
load("fansimsSkeleton.RData")
source("data_to_load.R") #getwd()
processFile("2015week01.csv")
genMtx() #strategies
simParams()
littleSim()
setwd("D:/Documents/GitHub/fs2")
load("fansimsSkeleton.RData")
source("data_to_load.R") #getwd()
processFile("2015week01.csv")
genMtx() #strategies
simParams()
littleSim()
source("data_to_load.R") #getwd()
processFile("2015week01.csv")
genMtx() #strategies
simParams()
littleSim()
save.image("useWeeklyFile.RData")
input <- data.frame(players = 100, first = 225, second = 125, third = 50)
results <- calcWinners(input$players)
winDollars <- round(as.data.frame(t((results %*% c(input$first, input$second, input$third)))), 1)
inTheMoney <- round(rowSums(results %*% (1*(c(input$first, input$second, input$third) > 0))), 2)
data <- as.data.frame(cbind(gameRanks, favorites, strategies[,order(-winDollars()[1,])[1:3]]))
colnames(data) <- c("Confidence", "$ Favorites", "$1st","$2nd","$3rd")
data
data <- as.data.frame(cbind(gameRanks, favorites, strategies[,order(-winDollars[1,])[1:3]]))
colnames(data) <- c("Confidence", "$ Favorites", "$1st","$2nd","$3rd")
data
sapply(winDollars[1,order(-winDollars)], dollar)[1]
library(shiny); library(scales)
sapply(winDollars[1,order(-winDollars)], dollar)[1]
input <- data.frame(players = 100, first = 100, second = 75, third = 50)
winDollars <- round(as.data.frame(t((results %*% c(input$first, input$second, input$third)))), 1)
inTheMoney <- round(rowSums(results %*% (1*(c(input$first, input$second, input$third) > 0))), 2)
data <- as.data.frame(cbind(gameRanks, favorites, strategies[,order(-winDollars[1,])[1:3]]))
colnames(data) <- c("Confidence", "$ Favorites", "$1st","$2nd","$3rd")
data
sapply(winDollars[1,order(-winDollars)], dollar)[1]
altUpsetPoints <<- t(crossprod(altUpsets[selectRowsPrem,selectRowsPrem,  drop = F], simOutcomes2))
altUpsets
altUpsetPoints2 <<- t(crossprod(altUpsets2[selectRowsPrem,selectRowsPrem,  drop = F], simOutcomes2) +
crossprod(altUpsetsRow[selectRowsPrem,selectRowsPrem,  drop = F], (1 - simOutcomes2)))
altStratMatrix <<- matrix(cbind(altUpsetPoints[resultIndex], altUpsetPoints2[resultIndex,]), nrow = 2000)
rm(list = ls())
genGameRanks <- function(nGames = 16) {nGames:1}
# generate square matrix with each column == gameRanks
genSq <- function(nGames = 16){
matrix(rep(genGameRanks(nGames), times = nGames), ncol = nGames)
}
#genSq(14)
genZeroSq <- function(nGames = 16){
matrix(rep(0, nGames^2), ncol = nGames)
}
nGames = 16
altFavs <- genZeroSq(nGames)
altUpsets <- altFavs
altUpsetsRow <- altUpsets
startRanks <- genSq(nGames)
topCol = 5
altUpsets <- startRanks
for (j in 1:nGames){ #j = 1
threshold <- (nGames + 1 - j)
if (j < topCol){
altUpsets[j:(topCol - 1) ,j] <- startRanks[(j + 1):topCol ,j]
}
if (j > topCol){
altUpsets[(topCol + 1):j ,j] <- startRanks[topCol:(j-1) ,j]
}
}
altUpsets[topCol, ] <- genGameRanks(16)
altUpsets2 <- altUpsets
altUpsets2[topCol, ] <- 0
altUpsetsRow[topCol, ] <- genGameRanks()
ls()
save.image("altStuff.RData")
rm(list = ls())
load("fansimsSkeleton.RData")
source("data_to_load.R") #getwd()
processFile("2015week01.csv")
genMtx() #strategies
rm(list = ls())
load("fansimsSkeleton.RData")
load("altStuff.RData")
source("data_to_load.R") #getwd()
processFile("2015week01.csv")
genMtx() #strategies
simParams()
littleSim()
save.image("useWeeklyFile.RData")
input <- data.frame(players = 100, first = 100, second = 75, third = 50)
results <- calcWinners(input$players)
winDollars <- round(as.data.frame(t((results %*% c(input$first, input$second, input$third)))), 1)
inTheMoney <- round(rowSums(results %*% (1*(c(input$first, input$second, input$third) > 0))), 2)
data <- as.data.frame(cbind(gameRanks, favorites, strategies[,order(-winDollars[1,])[1:3]]))
colnames(data) <- c("Confidence", "$ Favorites", "$1st","$2nd","$3rd")
data
sapply(winDollars[1,order(-winDollars)], dollar)[1]
winDollars
altResultsMatrix
rm(list = ls())
load("fansimsSkeleton.RData")
load("altStuff.RData")
source("data_to_load.R") #getwd()
processFile("2015week01.csv")
genMtx() #strategies
simParams()
littleSim()
# calcWinners(250)
# rankMatrix <- littleSim(numFans = 250, totalPointsMatrix = totalPointsIter,
#                       upsetPointsMatrix = upsetPoints)
save.image("useWeeklyFile.RData")
library(shiny); library(scales)
results <- calcWinners(input$players)
winDollars <- round(as.data.frame(t((results %*% c(input$first, input$second, input$third)))), 1)
input <- data.frame(players = 100, first = 100, second = 75, third = 50)
results <- calcWinners(input$players)
winDollars <- round(as.data.frame(t((results %*% c(input$first, input$second, input$third)))), 1)
inTheMoney <- round(rowSums(results %*% (1*(c(input$first, input$second, input$third) > 0))), 2)
data <- as.data.frame(cbind(gameRanks, favorites, strategies[,order(-winDollars[1,])[1:3]]))
colnames(data) <- c("Confidence", "$ Favorites", "$1st","$2nd","$3rd")
data
winDollars
dataI1 <- as.data.frame(cbind(gameRanks, favorites, strategies[,order(-inTheMoney[1:3]]))
dataI1 <- as.data.frame(cbind(gameRanks, favorites, strategies[,order(-inTheMoney[1:3]])))
inTheMoney
altStratMatrix
altResultsMatrix
rowSums(altResultsMatrix)
altUpsets2
